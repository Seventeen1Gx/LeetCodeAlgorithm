// 458. 可怜的小猪
//
// 有 1000 只水桶，其中有且只有一桶装的含有毒药，其余装的都是水。
// 它们从外观看起来都一样。如果小猪喝了毒药，它会在 15 分钟内死去。
//
// 问题来了，如果需要你在一小时内，弄清楚哪只水桶含有毒药，你最少需要多少只猪？
//
// 回答这个问题，并为下列的进阶问题编写一个通用算法。
// 进阶:
// 假设有 n 只水桶，猪饮水中毒后会在 m 分钟内死亡，你需要多少猪（x）就能在 p 分钟内找出 “有毒” 水桶？
// 这 n 只水桶里有且仅有一只有毒的桶。
//
// 提示：
// 可以允许小猪同时饮用任意数量的桶中的水，并且该过程不需要时间。
// 小猪喝完水后，必须有 m 分钟的冷却时间。在这段时间里，只允许观察，而不允许继续饮水。
// 任何给定的桶都可以无限次采样（无限数量的猪）。


package src;

public class PoorPig {
    // 1) 每只猪的状态
    // 测试时间/存活时间=0，一只猪最多测试 0 次，在测试时间结束时，猪只有存活一种状态
    // 测试时间/存活时间=1，一只猪最多测试 1 次，在测试时间结束时，猪有 2 种状态，存活，死亡
    // 测试时间/存活时间=2，一只猪最多测试 2 次，在测试时间结束时，猪有 3 种状态，存活，第一次测试后死亡，第二次测试后死亡
    // ...
    // 猪的状态 = 测试时间/存活时间 + 1
    //
    // 2) x 只两状态猪最多可测试多少桶水
    // 1 只猪只能测试 1 桶水，因为喝下后，测试时间结束时，死亡代表有毒，存活代表没毒
    // 2 只猪能测试 4 桶水，猪 A 喝 1、2 号水桶，猪 B 喝 2，3 号水桶，测试时间结束，有 4 种可能
    //       猪 A 死，猪 B 活，桶 1 有毒
    //       猪 A 活，猪 B 死，桶 3 有毒
    //       猪 A 活，猪 B 活，桶 4 有毒（因为有且仅有一只有毒的桶）
    //       猪 A 死，猪 B 死，桶 2 有毒
    // ...
    // x 只 2 状态猪，最多测试 2^x 桶水
    //
    // 3) x 只 s 状态猪最多可测试多少桶水
    // 同理，x 只 s 状态的猪最多可测试 s^x 桶水
    //
    // 故我们求最小的 x，使得 s^x >= n 即可

    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {
        int states = minutesToTest / minutesToDie + 1;
        return (int) Math.ceil(Math.log(buckets) / Math.log(states));
    }
}
